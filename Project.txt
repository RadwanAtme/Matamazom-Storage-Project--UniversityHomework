3 חלק רטוב – מתמאזום – מערכת לניהול מחסן מוצרים
לאור כניסתן של ענקיות המסחר המקוון לישראל, הוחלט בטכניון ליצור עסק מתחרה בשם מתמאזום. על
הסטודנטים מקורס מת“מ הוטל לבנות את המערכת הממוחשבת ששולטת במלאי המוצרים הקיימים, כולל
היכולת להוסיף מוצרים חדשים, להסיר מוצרים, ליצור ולשלח הזמנות מחוץ למחסן וכו'.
אנו נבנה את המערכת בשני שלבים. בשלב הראשון נבנה מבנה נתונים גנרי Set Amount ,בדומה למבני
הנתונים שלמדנו בכיתה. בשלב השני נשתמש במבנה הנתונים הנ"ל כדי לבנות את מערכת מתמאזום.
1.3 מימוש מבנה נתונים גנרי – Set Amount
בחלק זה נממש ADT גנרי עבור "סט כמותי" – סט של איברים יחודיים, אשר בנוסף מחזיק לכל איבר את
הכמות שלו בסט. הממשק של הסט נמצא בקובץ h.set_amount .עליכם לכתוב את הקובץ c.set_amount ,
אשר מממש את מבנה הנתונים המתואר.
מאחר ומבנה הנתונים גנרי, יש לאתחל אותו עם מספר מצביעים לפונקציות אשר יגדירו את אופן הטיפול
בעצמים המאוחסנים בו.
כדי לאפשר למשתמשים בסט )לא למפתחי הסט!( לעבור על איבריו סדרתית, לכל סט מוגדר איטרטור )מלשון
איטרציה, מעבר על איברים( פנימי ויחיד שבעזרתו יוכל המשתמש לעבור על כל איברי הסט. האיטרציה על
איברי ה סט צריכה להבטיח למשתמש מעבר על האיברים בסדר עולה מאיבר הקטן ל איבר הגדול – נדע
לעשות זאת באמצעות פונקציית השוואת האיברים )compareElements )שמסופקת בעת יצירת הסט.
פונקציית compare מחזירה 0 אם שני האיברים שהיא מ קבלת שווים, ערך חיובי אם המפתח הראשון גדול
מהשני, וערך שלילי אם המפתח השני גדול מהראשון )בדומה ל-strcmp .)
1.1.3 פונקציות שנדרש לממש
להלן תיאור קצר של הפונקציות אותן אתם נדרשים לממש. פירוט נוסף, כולל משמעות הפרמטרים וערכי
החזרה האפשריים של כל פונקציה, נמצא בקובץ h.set_amount .על המימוש שתספקו לענות על דרישות כל
התיעוד )המובא כאן ובקובץ ה-h )ויש להניח שכל דרישות התיעוד ייבדקו. במידת הצורך לאחר פרסום
התרגיל יפורסמו הבהרות על ידי סגל הקורס והן יהיו מחייבות עבור המימוש שתספקו. ההבהרות שיפורסמו
יעודכנו בקובץ ה-h שסופק לכם וכמו כן בכתב מודגש בצהוב בחלק זה.
חדש סט יצירת 3.1.1.1
AmountSet asCreate(CopyASElement copyElement, FreeASElement freeElement,
CompareASElements compareElements);
יוצר סט חדש ריק.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
 קיים סט הריסת 3.1.1.2
void asDestroy(AmountSet set);
הורס סט ואת כל האיברים שהוא מכיל.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
סט העתקת 3.1.1.3
AmountSet asCopy(AmountSet set);
יוצר סט חדש בעל אותן פונקציות גנריות כמו set ,ומעתיק לתוכו את כל האיברים מ-set ואת הכמות של כל
איבר.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
4.1.1.3 החזרת מספר האיברים בסט
int asGetSize(AmountSet set);
כל איבר נספר פעם אחת, ללא תלות בכמות שלו בסט.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
5.1.1.3 בדיקה האם איבר נמצא בסט
bool asContains(AmountSet set, ASElement element);
מחזיר true אם element נמצא ב -set ,ו-false אחרת.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
6.1.1.3 החזרת הכמות של איבר בסט
AmountSetResult asGetAmount(AmountSet set, ASElement element, double
*outAmount);
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
7.1.1.3 רישום איבר חדש לסט
AmountSetResult asRegister(AmountSet set, ASElement element);
מכניס איבר חדש לסט, עם הכמות 0 .כלומר, לאחר פעולה זו, האיבר החדש "נמצא בסט עם כמות אפס ".
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
8.1.1.3 שינוי הכמות של איבר קיים בסט
AmountSetResult asChangeAmount (AmountSet set, ASElement element, const
double amount);
משנה את הכמות של איבר בסט. אם amount חיובי אז מגדיל, אם שלילי אז מקטין, ואם amount הוא אפס
אז אין שינוי. לא ניתן לבצע פעולה זו עבור איבר שטרם הוכנס לסט או שכבר הוצא מהסט.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
הבהרה: אפילו אם amount הוא אפס, עדיין צריך להחזיר EXIST_NOT_DOES_ITEM_AS אם element לא
קיים ב -set ו-SUCCESS_AS אם element כן קיים ב -set .
הבהרה: אסור שהכמות של איבר בסט תהיה שלילית. אם amount הוא שלילי וביצוע הפעולה יגרום לכמות
של האיבר בסט לרדת מתחת לאפס, אז הפעולה צריכה להיכשל ולהחזיר AMOUNT_INSUFFICIENT_AS .
 מהסט איבר מחיקת 3.1.1.9
AmountSetResult asDelete(AmountSet set, ASElement element);
מוציא איבר קיים מהסט ומוחק את האיבר. כלומר, לאחר פעולה זו, האיבר כבר לא נמצא בסט, אפילו לא " עם
כמות אפס". 
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
הסט ריקון 3.1.1.10
AmountSetResult asClear(AmountSet set);
מוחק את כל האיברים מהסט. כלומר, לאחר פעולה זו, הסט נמצא במצב זהה למצבו מיד אחרי היצירה
הראשונית שלו.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
11.1.1.3 הזזת האיטרטור לתחילת הסט והחזרת האיבר הראשון
ASElement asGetFirst(AmountSet set);
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
12.1.1.3 קידום האיטרטור והחזרת האיבר המוצבע על ידו
ASElement asGetNext(AmountSet set);
הקידום מבוצע לפי הסדר שמוגדר על איברי הסט, מהקטן לגדול.
- פרמטרים: ראו קובץ h.set_amount
- ערכי חזרה: ראו קובץ h.set_amount
2.1.3 דרישות והערות נוספות
- עבור מימוש ה -Set Amount ,מותר להשתמש רק בספריה הסטנדרטית של C .בפרט, אין להשתמש
ב-set ו-list שמומשו ע"י סגל הקורס.
- לכל פונקציה המחזירה AmountSetResult מפורטים ערכי השגיאה האפשריים לה. במקרה
שפונקציה מקבלת קלט שמתאימים לו יותר מערך שגיאה אחד, יש להחזיר את ערך השגיאה הראשון
כפי שמופיע בתיעוד הפונקציה בקובץ ה-h .
- עליכם להניח כי לא יתכנו מקרי שגיאה פרט לאלו המצוינים בתיעוד של כל פונקציה. בניגוד לאמור
לעיל עבור שגיאה המעידה על בעיית זיכרון יש להחזיר מכל פונקציה בה היא מתרחשת את הערך
MEMORY_OF_OUT_AS אם ערך החזרה שלה הוא מטיפוס AmountSetResult ,או NULL אם ערך
החזרה שלה הוא מצביע.
- במקרה של שגיאה יש לשמור על שלמות מבנה הנתונים ולוודא שאין דליפות זיכרון.
- במקרה של שגיאה, מבנה הנתונים ביציאה מהפונקציה צריך להיות זהה למצבו בכניסה לפונקציה.
- אין הגבלה על מספר האיברים בסט.
- בהתאם לתיעוד בקובץ ה-h ,ישנן פונקציות שאחרי הקריאה להן מצב האיטרטור ל א מוגדר, או שלא
מצוין מצבו. אם לא מצוין מצב האיטרטור, המשמעות היא שמצב האיטרטור אחרי הקריאה לפונקציה
הוא לא מוגדר. כאשר איטרטור נמצא במצב זה, זה אומר שאסור למשתמש להניח משהו עליו, כלומר
שאינכם צריכים להבטיח שום דבר בנוגע לערך האיטרטור ואתם יכולים לשנות אותו כרצונכם. זה בא
בשביל להקל עליכם. שימו לב, האיטרטור נמצא במצב מוגדר רק בסוף פונקציות עבורן מצוין בתיעוד
במפורש שזה המצב.
- שימו לב להבדל בין הכנסה של איבר חדש לסט לבין הוספה של איבר קיים לסט – הכנסה של איבר
חדש גורמת לסט "להכיר" את האיבר הזה, אבל בהוספת איבר קיים ניתן אך ורק לשנות את הכמות
של איבר שהסט כבר "מכיר".
- באופן דומה, שימו לב להבדל בין מחיקה של איבר לבין שינוי הכמות של איבר – מחיקה גורמת לסט
"לשכוח" שהאיבר היה קיים אי פעם, אבל הוספת כמו ת שלילית לא יכולה לגרום לסט "לשכוח" את
האיבר, אפילו אם הכמות שלו יורדת לאפס. 
2.3 מימוש מערכת לניהול מחסן מוצרים – מתמאזום
1.2.3 טיפוס נתונים ראשי
המערכת מרוכזת תחת טיפוס נתונים בשם Matamazom ,להלן המחסן שלנו. המחסן נדרש להיות בעל מספר
יכולות אשר יפורטו כעת:
ניהול מלאי המחסן:
- למחסן זה ניתן להוסיף מוצרים שונים. המוצרים מזוהים על ידי מספר פרמטרים:
- שם מוצר מטיפוס מחרוזת
- מספר מזהה מוצר ייחודי לו id מטיפוס int unsigned
- מידע מותאם אישית מטיפוס MtmProductData אשר מוצהר ב h.matamazom ומחזיק מידע רלוונטי
נוסף על כל מוצר. לדוגמא המחיר ליחידת מידה עבור ירקות הוא שקל לקילוגרם ואילו עבור מכשירי
חשמל המחיר הוא ליחידה שלמה אחת.
- יחידת המידה של המוצר. כל מוצר הוא בעל יחידות שלמות, חצי- שלמות או רציפות. לדוגמה,
טלוויזיה ניתן למכור רק ביחידות שלמות, אבטיח ניתן למכור בשלמים או בחצאים, מלפפונים ניתן
למכור לפי משקל כלשהו )יחידה רציפה(. יחידות המידה המותרות הן היחידות המופיעות ב-
MatamazomAmountType .יחידת המידה של מוצר קובעת מהן הכמויות המותרות של המוצר
במחסן ובהזמנה )ראו פירוט בקובץ ה-h .)
- באופן כללי טיפוס זה הוא למימושכם ויכול להחזיק כל מידע שתמצאו רלוונטי להחזיק לצורכי
התרגיל.
הבהרה : יצוין פה כי לא תיתכן כפילות של מוצרים במחסן. כלומר במידה ואנו מוכרים תפוחים במחסן ייתכן כי
מלאי התפוחים ירד ויעלה לאורך התוכנית, אך לא ייתכן מצב בו יש יותר ממוצר אחד המזוהה על ידי id
המתאים לתפוחים.
ניהול הזמנות:
חלק נוסף במחסן שלנו הוא היכולת לקבל הזמנות מלקוחות. ההזמנות עשויות להכיל מספר מוצרים מכמויות
שונות. כל הזמנה מזוהה על ידי מספר מזהה ייחודי לה מטיפוס int unsigned אשר יבדיל אותה משאר
ההזמנות הקיימות במערכת. ביצוע הזמנה מורכב מ-3 שלבים אשר לא מתחייב שיתרחשו בצמוד:
1 .יצירת הזמנה חדשה.
2 .הוספת מוצרים להזמנה לפי בחירת הלקוח.
3 .שילוח ההזמנה.
הבהרות בנוגע לניהול ההזמנות:
- יצירת הזמנה אינה אומרת שילוח הזמנה. כפי שאתם מוסיפים מוצרים ל"סל" בעת הזמנות באינטרנט
הסל שומר על מצבו עד אשר תחליטו לבצע out check .יתכן מצב בו קיימים בהזמנה מוצרים
שאזלו מן המלאי או שנוסיף להזמנה מוצר מכמות שגדולה מהכמות הקיימת במחסן. עם זאת לא
ייתכן מצב שנוסיף להזמנה מוצר שהמחסן "לא מכיר" כלומר אינו קיים בו כלל. לפירוט המלא ראו
את התיעוד בקובץ h.matamazom
- לא ייתכן מצב בו לשתי הזמנות אותו מספר מזהה.
- ייתכנו מספר הזמנות הקיימות בו זמנית במערכת . חשבו איזה מבנה נתונים מתאים על מנת לקיים
את הדרישה הזו.
ניהול הכנסות:
לאחר ששולחה הזמנה )ראו פירוט על פונקצית mtmShipOrder בהמשך( המחסן בעצם " עשה רווח ", להלן
"הכנסה". אם לדוגמא טלוויזיה עולה 500 ,ולקוח יצר הזמנה עם 2 טלוויזיות אז לאחר שילוח ההזמנה
)mtmShipOrder )המחסן עשה "הכנסה" של 1000 עבור המוצר הזה . יש לעקוב אחר ההכנסות של
המוצרים השונים לאורך התכנית. כלומר מהזמנה להזמנה ההכנסות ממוצר מסוים יכולות לגדול.
הבהרות בנוגע לניהול ההכנסות:
- שימו לב שלא יתכן מצב בו ההכנסות קטנות, אלא רק גדלות. 
- ייתכן מצב בו היו הכנסות ממוצר מסוים ולאחר מכן המוצר הוסר לחלוטין מהמחסן. במצב שכזה אין
צורך לשמור את התיעוד שהיה על ההכנסות ממוצר זה.
הבהרה : בחלק 2.3 ניתן להשתמש בlist ו - set שסופקו לכם על ידי סגל הקורס ואנו ממליצים לכם גם לעשות
שימוש בset_amount שכתבתם בחלק הקודם
2.2.3 פונקציות ומבני נתונים שנדרש לממש
להלן תיאור קצר של הפונקציות אותן אתם נדרשים לממש. פירוט נוסף, כולל משמעות הפרמטרים וערכי
החזרה האפשריים של כל פונקציה, נמצא בקובץ h.matamazom .על המימוש שתספקו לענות על דרישות כל
התיעוד )המובא כאן ובקובץ ה-h )ויש להניח שכל דרישות התיעוד ייבדקו. במידת הצורך לאחר פרסום
התרגיל יפורסמו הבהרות על ידי סגל הקורס והן יהיו מחייבות עבור המימוש שתספקו. ההבהרות שיפורסמו
יעודכנו בקובץ ה-h שסופק לכם וכמו כן בכתב מודגש בצהוב בחלק זה.
1.2.2.3 מבני נתונים וטיפוסים נוספים
Matamazom – מצביע לטיפוס מבנה הנתונים כפי שמוסבר בחלק הקודם.
MtmProductData – מצביע למידע "מותאם" למוצר.
(MtmProductData)(MtmCopyData (*MtmProductData – מצביע לטיפוס של פונקציה המיועדת להעתקת
המידע המותאם של כל מוצר.
(MtmProductData)(MtmFreeData (*void – מצביע לטיפוס של פונקציה המיועדת לשחרור המידע המותאם
של כל מוצר.
 פונקציה של לטיפוס מצביע – double (*MtmGetProductPrice)(MtmProductData, const double amount)
המיועדת בהינתן כמות רצויה amount ומידע על מוצר MtmProductData להחזיר את המחיר של המוצר
ביחס לכמות הרצויה. ניתן להניח ש -amount הוא בעל ערך תקין למוצר.
bool (*MtmFilterProduct)(const unsigned int id, const char *name, const double amount,
(customData MtmProductData – מצביע לטיפוס של פונקציה המיועדת לסינון מוצרים על פי פרמטרים
שנקבעו מראש. הפונקציה תעבור על מוצרים שנמצאים במלאי המחסן בלבד. לדוגמא אם תתבקשו להחזיר
את כל המוצרים במחסן אשר מחירם נמוך מ -5 שקלים ליחידת מידה תוכלו לעשות זאת על ידי שימוש בטיפוס
הגנרי הנ"ל. רא ו דוגמא בתיעוד הקוד. ניתן להניח ש-amount בעל ערך תקין למוצר.
הערה מנחה לגבי הטיפוסים והפונקציות עד כה: בניגוד לדוגמאות שראיתם בתרגול ובהרצאה, שם הממשק
הגנרי היה חלק מהכלי אותו מימשנו בלבד )לדוגמא מחסנית גנרית בתרגול(, עבור תרגיל זה ישנה רמה
נוספת של גנריות. לדוגמא, במקום שלמחסן שלנו תהיה פונקציה יחידה אשר מחזירה לנו את המחיר עבור כל
מוצר במחסן. על המשתמש לספק את הפונקציה הזו לכל מוצר ומוצר כי למוצרים שונים ייתכן חישוב שונה של
המחיר )לדוגמא בהינתן מבצעים, הנחות וכו'(.
הפונקציות הבאות אינן דורשות כל גנריות וע ליכם לכתוב אותה בצורה שהכי נוחה לכם.
מחסן יצירת 3.2.2.2
Matamazom matamazomCreate();
פונקציה היוצרת את המחסן שלנו ומחזירה את טיפוס הנתונים המדובר Matamazom .
 מחסן הריסת 3.2.2.3
void matamazomDestroy(Matamazom matamazom);
פונקציה שבהינתן מחסן מטיפוס Matamazom משחררת את כל הזיכרון שהוקצה עד כה לטובת בניית מחסן
זה. יש לוודא שאין זליגות זיכרון כמוסבר בהמשך.
4.2.2.3 רישום מוצר חדש למחסן
MatamazomResult mtmNewProduct(Matamazom matamazom, const unsigned int id,
const char *name, const double amount, const MatamazomAmountType
amountType, const MtmProductData customData, MtmCopyData copyData,
MtmFreeData freeData, MtmGetProductPrice prodPrice);
פונקציה שבהינתן כל המידע הדרוש על מוצר חדש יוצרת את המוצר ומכניסה אותו למחסן. אם אחד
הפרמטרים לא תקין, יש להחזיר ערך שגיאה מתאים.
matamazom, name, customData, copyData, freeData, מהארגומנטים אחד אם: הבהרה
prodPrice הוא NULL יש להחזיר את קוד השגיאה ARGUMENT_NULL_MATAMAZOM
5.2.2.3 שינוי המלאי של מוצר במחסן
MatamazomResult mtmChangeProductAmount(Matamazom matamazom, const unsigned
int id, const double amount);
פונקציה אשר תפקידה בהינתן מחסן, מזהה מוצר הקיים במחסן וכמות, להוסיף /להחסיר את הכמות
שהועברה כארגומנט למלאי הקיים במחסן. אם הכמות שהועברה )amount )היא מספר חיובי יש להוסיף את
הכמות הזו למלאי, אם הכמות שלילית יש להחסיר את הכמות הזו ממלאי המחסן, ואם הכמות שהועברה היא
0 אין לעשות דבר.
הבהרה: אם אחד הפרמטרים לא תקין, יש להחזיר ערך שגיאה )לא SUCCESS_MATAMAZOM )אפילו אם
amount הוא אפס.
מהמחסן מוצר מחיקת 3.2.2.6
MatamazomResult mtmClearProduct(Matamazom matamazom, const unsigned int
id);
פונקציה אשר תפקידה, בהינתן מחסן ומזהה מוצר, להסיר את המוצר בעל המזהה שהועבר כארגומנט מן
המחסן לחלוטין. המוצר יימחק והזיכרון שתפס במחסן ישוחרר. בנוסף, יש למחוק את המוצר מכל הזמנה
קיימת שבה הוא מופיע.
 חדשה הזמנה יצירת 3.2.2.7
unsigned int mtmCreateNewOrder(Matamazom matamazom);
פונקציה אשר תפקידה הוא ליצור הזמנה חדשה ריקה. הפונקציה תחזיר מספר מטיפוס int unsigned אשר
יהווה את המספר המזהה הייחודי עבור הזמנה זו ואשר יבדיל אותה מכל שאר ההזמנות אשר קיימות
במערכת. ניתן להניח שכמות ההזמנות שיבוצעו במהלך ריצת התוכנית קטן מהערך המקסימלי הניתן לייצוג
ע"י טיפוס int unsigned.יובהר פה שוב כי ייתכן שבמחסן יהיו מספר הזמנות במקביל . לדוגמ א, לאחר 2
קריאות רצופות לפונקציה זו ייוצרו 2 הזמנות ריקות בעלי מספר מזהה שונה
8.2.2.3 שינוי כמות מוצר בהזמנה
MatamazomResult mtmChangeProductAmountInOrder(Matamazom, const unsigned int
orderId, const unsigned int productId, const double amount);
פונקציה אשר בהינתן מחסן, מספר הזמנה קיימת, מספר מוצר וכמות רצויה מן המוצר, תוסיף /תחסיר את
הכמות שהועברה. כמקודם אם הכמות גדולה מאפס היא תתווסף למוצר בהזמנה ואם היא קטנה מאפס היא
תוחסר מן המוצר שבהזמנה )עבור העברה של כמות 0 כמות המוצר בהזמנה נשארת ללא שינוי (. שימו לב כי
ייתכן מצב בו נוסיף להזמנה מוצר שאזל מן המלאי, אך לא מוצר שכבר נמחק או לא היה קיים מעולם במחסן.
הבהרה: פונקציה זו משמשת להוספת מוצרים חדשים להזמנה קיימת , ראו את התיעוד בh להסברים נוספים.
הבהרה: אם אחד הפרמטרים לא תקין , יש להחזיר ערך שגיאה )לא SUCCESS_MATAMAZOM )אפילו אם
amount הוא אפס.
הערה חשובה:
יש לשים לב כי יצירת הזמנה של מוצר Y עם כמות X אין משמעותה שיש באותו הרגע להפחית את הכמות X
מן המלאי הקיים במחסן של המוצר Y .
 הזמנה שילוח 3.2.2.9
MatamazomResult mtmShipOrder(Matamazom matamazom, const unsigned int
orderId);
פונקציה אשר בהינתן מחסן ומספר הזמנה תוציא הזמנה אל הפועל. כלומר במידה וכל המלאי הנדרש
להזמנה המדוברת קיים במחסן, הכמויות הדרושות יוחסרו ממלאי המחסן וההזמנה תמחק ממאגר ההזמנות
הקיימות במערכת.
 הזמנה ביטול 3.2.2.10
MatamazomResult mtmCancelOrder(Matamazom matamazom, const unsigned int
orderId);
בהינתן מחסן ומספר הזמנה, תבוטל ההזמנה המדוברת, ותוסר ממאגר ההזמנות הקיימות במערכת.
11.2.2.3 הדפסת מלאי המוצרים במחסן
MatamazomResult mtmPrintInventory(Matamazom matamazom, FILE *output);
בהינתן מחסן וקובץ פלט יודפס כל מלאי המחסן אל הקובץ, ממוי ן לפי ה -id של המוצר מן הקטן לגדול לפי
הפורמט הבא. תחילה יש להדפיס את הכותרת ":Status Inventory "ולאחר מכן יש להדפיס את פרטי
המוצרים הקיימים במחסן בשורות נפרדות. אין להוסיף רווחים מיותרים בסוף שורה.
Inventory Status:
name: <name>, id: <id>, amount: <existing amount>, price: <price per unit>
השורה הראשונה היא הכותרת. השורה השנייה היא פורמט ההדפסה לכל מוצר. כלומר לכל מוצר הקיים
במחסן יש להדפיס שורה המתאימה לו. id הוא מזהה המוצר הייחודי לו , name הוא שם המוצר, amount הוא
כמות המוצר הקיימת במלאי המחסן ו-price הוא המחיר של המוצר ליחידת מדידה. לדוגמא מחיר טלוויזיה
הוא עבור יחידה אחת ומחיר תפוחים הוא עבור קילוגרם.
שימו לב: עבור ההדפסה של כל שורת מוצר עליכם לעשות שימוש בפונקציה mtmPrintProductDetails
שסופקה לכם בקובץ h.print_matamazom .
דגש: עבור מחסן קיים שאינו מכיל מוצרים יש להדפיס את הכותרת ובזאת לסיים את ההדפסה כי אין מוצרים
להדפיס.
דוגמה:
Inventory Status:
name: Apple, id: 0, amount: 205.4, price: 10.9
name: TV, id: 15, amount: 51, price: 1299
 הזמנה הדפסת 3.2.2.12
MatamazomResult mtmPrintOrder(Matamazom matamazom, const unsigned int
orderId, FILE *output);
בהינתן מחסן, מספר הזמנה וקובץ פלט תודפס ההזמנה אל קובץ הפלט לפי הפורמט הבא.
בהדפסת הזמנה יש תחילה להדפיס כותרת המזהה את ההזמנה המודפסת לפי ה -id המתאים לה. לאחר מכן
בשורות נפרדות יש להדפיס את תוכן ההזמנה, כלומר המוצרים המרכיבים אותה. לבסוף יש להדפיס " שורת
סיכום" .
Order <order id> Details:
name: <name>, id: <id>, amount: <amount in order>, price: <price for amount>
----------
Total Price: <total price for the entire order>
פורמט השורה למוצר זהה לקודם פרט לכך שכעת amount מפרט את כמות המוצר בהזמנה זו. price כעת
מתאר את המחיר למוצר עבור הכמות שנמצאת בהזמנה. בסוף הדפסת המוצרים יש להדפיס את "שורת
הסיכום". שורה זו מורכבת מ- 2 שורות נפרדות: בראשונה יש להדפיס 10 תווי '- ' . בשנייה יש להדפיס לפי
הפורמט הנראה למעלה את סך העלות הכוללת עבור הזמנה זו. 
דגש: במידה וההזמנה קיימת אך אין בה מוצרים יש להדפיס את הכותרת ואת "שורת הסיכום באופן מתאים,
כלומר עלות הזמנה שכזו המכילה 0 מוצרים היא 0 .
שימו לב: עבור ההדפסה של הכותרת , שורות המוצר ושורת הסיכום עליכם לעשות שימוש בפונקציות
mtmPrintProductDetails, mtmPrintOrderHeading ו-mtmPrintOrderSummary בהתאמה שסופקו לכם
.matamazom_print.h בקובץ
דוגמה להדפסת הזמנה:
Order 3 Details:
name: Apple, id: 0, amount: 1.4, price: 15.26
name: TV, id: 15, amount: 2, price: 2598
----------
Total Price: 2613.26
13.2.2.3 הדפסת המוצר המכניס ביותר
MatamazomResult mtmPrintBestSelling(Matamazom matamazom, FILE *output);
פונקציה אשר בהינתן מחסן וקובץ פלט מדפיסה לקובץ הפלט את המוצר ה"מכניס" ביותר.הכוונה במכניס היא
סה"כ ההכנסות שנצברו משילוח של המוצר בהזמנות מתחילת התוכנית. ההדפסה תעשה לפי הפורמט הבא.
כותרת מתאימה ולאחר מכן הדפסת המוצר.
Best Selling Product:
name: <name>, id: <id>, total income: <total income from that product>
בפורמט השורה יודפס השם וה-id של המוצר, הפרמטר האחרון שיודפס הוא סך ההכנסה ממוצר זה מאז
שהמוצר נוסף למחסן.
שימו לב: עבור הדפסה זו עליכם לעשות שימוש בפונקציה mtmPrintIncomeLine שסופקה לכם בקובץ
 .matamazom_print.h
דגש: במידה ושני מוצרים הם בעלי אותה הכנסה ה-id של המוצרים ישמש כשובר שיווין. המוצר שיודפס יהיה
המוצר עם ה-id הקטן יותר.
בנוסף עבור מחסן שטרם עשה מכירות כלשהן אין הכנסה לאף מוצר, לכן במצב זה הפונקציה תדפיס:
Best Selling Product:
none
14.2.2.3 הדפסה של מוצרים נבחרים מהמחסן
MatamazomResult mtmPrintFiltered(Matamazom matamazom, MtmFilterProduct
customFilter, FILE *output);
פונקציה אשר מקבלת פונקציית פילטר ובהתאם לפילטר שקיבלה תדפיס מוצרים אשר עברו את הפילטור.
המוצרים שעברו פילטור ויודפסו הם מוצרים הנמצאים במתמאזום ולכן פורמט ההדפסה לכל שורה יהיה זהה
לפורמט בפונקציה mtmPrintInventory .כלומר לכל מוצר שעבר את הפילטור יש להדפיס את השורה:
name: <name>, id: <id>, amount: <existing amount>, price: <price per unit>
דגש: פונקציה זו לא מדפיסה כותרת וכמובן גם פה עליכם לעשות ש ימוש בפונקציה
 .mtmPrintProductDetails
3.2.3 דרישות והערות נוספות
- הנכם רשאים וכדאי לכם להשתמש בחלק הקודם של תרגיל זה על מנת לממש חלק זה.
- הפונקציות ומבני הנתונים אותם אתם נדרשים לממש נמצאים ומפורטים לרמת קלט פלט בקובץ
h.matamazom שסופק לכם.
- מסופקים לכם גם מבני הנתונים set ו- list שכבר מומשו על ידי סגל הקורס, וקבצי ה- o שלהם מוכלים
בקובץ a.libmtm .בשביל להשתמש בהם הוסיפו include #לקובץ c.matamazom .יש לדאוג כי 
הקבצים a.libmtm ,h.set ו-h.list שסופק ו לכם ימצאו בת יקיה הראשית ולקמפל לפי ההנחיות שבסוף
התרגיל. שימו לב כי ישנם כמה קבצי a.libmtm ,ועליכם לבחור את הגרסה המתאימה למערכת
ההפעלה בה אתם מקמפלים )מי שעובד עם " Linux for Subsystem Windows ( "WSL , )השתמשו
בגרסה של csl3 .)
- בנוסף מסופקים לכם h.print_matamazom ו -c.print_matamazom כדי לעזור לכם להדפיס בפורמט
הנכון.
- לכל פונקציה המחזירה MatamazomResult מפורטים ערכי השגיאה האפשריים לה. במקרה
שפונקציה מקבלת קלט שמתאימים לו יותר מערך שגיאה אחד, יש להחזיר את ערך השגיאה הראשון
כפי שמופיע בתיעוד הפונקציה בקובץ ה-h .
- עליכם להניח כי לא יתכנו מקרי שגיאה פרט לאלו המצוינים בתיעוד של כל פונקציה. בניגוד לאמור
לעיל עב ור שגיאה המעידה על בעיית זיכרון יש להחזיר מכל פונקציה בה היא מתרחשת את הערך
 .MATAMAZOM_OUT_OF_MEMORY
- במידה והתרחשה שגיאה על המערכת להישמר כאילו לא התבצעה הפעולה הגרמה לשגיאה.
3.3 דרישות נוספות לחלק הרטוב
Makefile 3.3.1
עליכם לספק Makefile כמו שנלמד בקורס עבור בניית הקוד של תרגיל זה.
- הכלל הראשון ב- Makefile יקרא matamazom ויבנה את התוכנית matamazom .
- הקובץ יכיל כלל בשם set_amount שיבנה תוכנית המריצה כמה טסטים על המימוש של Amount
 .Set
- אנו מצפים לראות שלכל ADT קיים כלל אשר בונה עבורו קובץ o .דבר שכפי שלמדתם בקורס –
אמור לחסוך הידור של כל התוכנית כאשר משנים רק חלק קטן ממנה.
- הוסיפו גם כלל clean ,אשר מוחק את כל תוצרי הקמפול )מחזיר את סביבת העבודה למצב "נקי"(.
- יש לכתוב את הקובץ כפי שנלמד וללא שכפולי קוד.
תוכלו לבדוק את ה- makefile שלכם באמצעות הרצת הפקודות "make "או "set_amount make "והפעלת
קבצי ההרצה שנוצרו. הנכם רשאים להשתמש בקבצים בתיקית tests על מנת לספק ל- Makefile פונקצית
 .main
2.3.3 הידור, קישור ובדיקה
התרגיל ייבדק על שרת csl3 ועליו לעבור הידור בעזרת הפקודות הבאות:
 :Amount Set עבור-
gcc -std=c99 –Wall -Werror -pedantic-errors –DNDEBUG -o amount_set
amount_set*.c tests/amount_set*.c
- עבור מתמאזום:
gcc -std=c99 -Wall -Werror -pedantic-errors –DNDEBUG -o matamazom *.c
tests/matamazom*.c -L. -lm -lmtm
עליכם לוודא שהרצה של פקודות אלו על csl3 אכן יוצרת את התוכניות הנדרשות מכם.
הערה לגבי הד גלים "lmtm -lm. -L :"-
- הדגל lm -מורה לקומפיילר לקשר לתוצר הסופי את הספריה so.libm ,שהיא ספריה המותקנת
בשרת ומכילה את המימוש של h.math .כלומר, ללא דגל זה לא ניתן לקמפל תוכנית המבצעת
 .math.h- ל include
- הדגל lmtm -מורה לקומפיילר לקשר לתוצר הסופי את הספריה a.libmtm .
- הדגל .L -מורה לקומפיילר להוסיף את התיקיה "." )שזו התיקיה ממנה מריצים את פקו דת ה-gcc )
לרשימת התיקיות בהן הוא מחפש ספריות בשלב הקישור. כלומר, ללא דגל זה הקומפיילר לא ימצא
את הספריה a.libmtm .
3.3.3 ולגרינד ודליפות זיכרון
המערכת חייבת לשחרר את כל הזיכרון שעמד לרשותה בעת ריצתה. על כן עליכם להשתמש ב -valgrind
שמתחקה אחר ריצת התוכנית שלכם, ובודק האם ישנם משאבים שלא שוחררו. הדרך לבדוק האם יש לכם 
דליפות בתוכנית היא באמצעות שתי הפעולות הבאות )שימו לב שחייב להיות main ,כי מדובר בהרצה
ספציפית(:
1 .קימפול של השורה לעיל עם הדגל g-
2 .הרצת השורה הבאה:
valgrind --leak-check=full ./matamazom
כאשר matamazom זה שם קובץ ההרצה.
הפלט ש -valgrind מפיק אמור לתת לכם, במידה שיש לכם דליפות, את שרשרת הקריאות שהתבצעו שגרמו
לדליפה. אתם אמורים באמצעות דיבוג להבין היכן היה צריך לשחרר את אותו משאב שהוקצה ולתקן את
התוכנית. בנוסף, valgrind מראה דברים נוספים כמו קריאה לא חוקית )למשל קריאה לזיכרון שכבר שוחרר( –
גם שגיאות אלו עליכם להבין מהיכן מגיעות ולתקן.
 התרגיל בדיקת 3.3.4
התרגיל ייבדק בדיקה יבשה )מעבר על קונבנציות הקוד והארכיטקטורה( ובדיקה רטובה.
הבדיקה היבשה כוללת מעבר על הקוד ובודקת את איכות הקוד )שכפולי קוד, קוד מבולגן, קוד לא ברור,
שימוש בטכניקות תכנות "רעות"(.
הבדיקה הרטובה כוללת את הידור התוכנית המוגשת והרצתה במגוון בדיקות אוטומטיות. על מנת להצליח
בבדיקה שכזו, על התוכנית לעבור הידור, לסיים את ריצתה, ולתת את התוצאות הצפויות.
4 אופן ההגשה
את ההגשה יש לבצע דרך אתר הקורס, תחת Submit Electronic -> HW1 -> Assignments .הקפידו על
הדברים הבאים:
- יש להגיש את pdf.dry של החלק היבש ואת קבצי הקוד וה -makefile של החלק הרטוב מכווצים
לקובץ zip( לא פורמט אחר(, כאשר כל הקבצים מופיעים בתיקיית השורש בתוך קובץ ה - zip .קבצים
הרלוונטיים רק ל-Set Amount יהיו בעלי שמות המתחילים ב-"set_amount ."
- עבור החלק הרטוב, יש להגיש אך ורק את קבצי ה-h וה - c אשר כתבתם בעצמכם ואת ה-
makefile אשר נדרשתם לכתוב. אין להגיש את הקבצים אשר סופקו לכם.
- הקבצים אשר מסופקים לכם יצורפו על ידינו במהלך הבדיקה. בפרט, ניתן להניח את קיום הקבצים
 .הראשית בתיקיה libmtm.a- ו matamazom.h ,amount_set.h ,set.h ,list.h
- ניתן להגיש את התרגיל מספר פעמים, רק ההגשה האחרונה נחשבת.
- על מנת לבטח את עצמכם נגד תקלות בהגשה האוטומטית, שמרו את קוד האישור עבור ההגשה.
עדיף לשלוח גם לשותף. כמו כן שמרו עותק של התרגיל של חשבון ה- csl3 שלכם לפני ההגשה
האלקטרונית ואל תשנו אותו לאחריה )שני הקובץ יגרור שינוי חתימת העדכון האחרון(.
o כל אמצעי אחר לא ייחשב הוכחה לקיום הקוד לפני ההגשה.
לנוחותכם, אנו מספקים סקריפט בשם py.check_final לשימושכם לצורך וידוא תקינות ההגשה. הסקריפט
מוודא שה -zip מכיל רק את הקבצים הנדרשים, ומנסה להדר את הקוד ולהריץ אותו. להרצת הסקריפט, הריצו
את השורה הבאה )כאשר zip.sol_ex1 הוא ה-zip שאתם עומדים להגיש(:
~mtmchk/public/1920a/ex1/final_check.py ex1_sol.zip
זכרו, הסקריפט הוא לצורכי נוחות בלבד, וזו עדיין אחריותכם לוודא שההגשה עומדת בכל התנאים